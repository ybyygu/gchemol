// [[file:~/Workspace/Programming/gchemol/gchemol.note::70e8dd41-45af-4712-b095-802079ac6eb4][70e8dd41-45af-4712-b095-802079ac6eb4]]
use parser::{
    end_of_line,
    take_until_end_of_line,
    space_token,
    xyz_array,
    alpha,
    digit,
    unsigned_digit,
    double_s,
};

use Molecule;
use Atom;

use nom::ErrorKind;

named!(poscar_lattice_constant<&str, f64>,
    terminated!(
        double_s,
        end_of_line
    )
);

#[test]
fn test_poscar_lattice_constant() {
    let x = poscar_lattice_constant("1.0000\n");
}

named!(poscar_cell_vectors<&str, [[f64; 3]; 3]>,
    dbg!(
        do_parse!(
            va: ws!(xyz_array) >>
            vb: ws!(xyz_array) >>
            vc: ws!(xyz_array) >>
            ([va, vb, vc])
        )
    )
);

#[test]
fn test_poscar_cell_vectors() {
    let (_, x) = poscar_cell_vectors(" 21.23300000  0.00000000  0.00000000
  0.00000000 26.60400000  0.00000000
  0.00000000  0.00000000 12.67600000\n").unwrap();
    assert_eq!(21.233, x[0][0]);
}

named!(poscar_ion_types<&str, (Vec<&str>, Vec<usize>)>,
    return_error!(
        ErrorKind::Custom(1),
        do_parse!(
            syms: many1!(sp!(alpha))          >>
                  end_of_line                 >>
            nums: many1!(sp!(unsigned_digit)) >>
                  end_of_line                 >>
            ((syms, nums))
        )
    )
);

#[test]
fn test_poscar_ion_types() {
    let x = poscar_ion_types(" O    Si   C    N    H
 225  112   8    1    19 \n");
}

// Selective dynamics
// Direct
named!(poscar_select_direct_lines<&str, (&str, &str)>,
    do_parse!(
        line1: sp!(take_until_end_of_line) >>
        line2: sp!(take_until_end_of_line) >>
        ((line1, line2))
    )
);

#[test]
fn test_poscar_select_direct_lines() {
    let x = poscar_select_direct_lines("Selective dynamics
Direct");
}

// 0.05185     0.39121     0.29921  T T T # O
// 0.81339     0.57337     0.68777  T T T # O
named!(poscar_position<&str, ([f64; 3], &str)>,
    do_parse!(
        position: sp!(xyz_array)                            >>
        remained: take_until_end_of_line                    >>
        ((position, remained))
    )
);

#[test]
fn test_poscar_position() {
    let x = poscar_position("     0.05185     0.39121     0.29921  T T T # O \n");
    let x = poscar_position("     0.05185     0.39121     0.29921 \n");
}

#[derive(Debug, Clone)]
struct PoscarData<'a> {
    title: &'a str,
    selective_dynamics: bool,
    direct_coordinates: bool,
    lattice_constant: f64,
    cell_vectors: [[f64;3]; 3],
    ion_types: (Vec<&'a str>, Vec<usize>),
    ion_positions: Vec<([f64; 3], &'a str)>
}

named!(poscar_data<&str, PoscarData>,
    do_parse!(
        title            : take_until_end_of_line     >>
        lattice_constant : poscar_lattice_constant    >>
        cell_vectors     : poscar_cell_vectors        >>
        ion_types        : poscar_ion_types           >>
        labels           : poscar_select_direct_lines >>
        ion_positions    : many1!(poscar_position)    >>
        (
            PoscarData {
                title,
                lattice_constant,
                cell_vectors,
                ion_types,
                selective_dynamics: labels.0.starts_with("S"),
                direct_coordinates: labels.1.starts_with("D"),
                ion_positions,
            }
        )
    )
);

fn poscar_molecule(txt: &str) -> Result<Molecule> {
    // TODO: how to handle nom parsing errors?
    let (_, poscar) = poscar_data(txt).unwrap();
    let mut mol = Molecule::new(poscar.title.trim());

    let mut tvs = poscar.cell_vectors;
    let mut lat = Lattice::new(tvs);
    lat.scale_by(poscar.lattice_constant);

    let mut symbols = vec![];
    let (syms, nums) = poscar.ion_types;

    for (&sym, &num) in syms.iter().zip(nums.iter()) {
        for _ in 0..num {
            symbols.push(sym);
        }
    }

    if symbols.len() != poscar.ion_positions.len() {
        bail!("Inconsistency: some ions data not correctly parsed.");
    }

    for (&sym, (pos, codes)) in symbols.iter().zip(poscar.ion_positions) {
        let mut pos = pos;
        if poscar.direct_coordinates {
            pos = lat.to_cart(pos);
        }
        let a = Atom::new(sym, pos);
        mol.add_atom(a);
    }
    mol.set_lattice(lat);

    Ok(mol)
}



#[test]
fn test_poscar_molecule() {
    let x = poscar_molecule("Molecule # generated by gosh
1.0
 21.23300000  0.00000000  0.00000000
  0.00000000 26.60400000  0.00000000
  0.00000000  0.00000000 12.67600000
 O    Si   C    N    H
225  112   8    1    19
Selective dynamics
Direct
     0.05185     0.39121     0.29921  T T T # O
     0.81339     0.57337     0.68777  T T T # O
     0.73422     0.23229     0.85313  T T T # O
     0.02246     0.05156     0.49349  T T T # O
     0.64451     0.66726     0.17130  T T T # O
     0.05185     0.07337     0.29921  T T T # O
     0.60095     0.57471     0.17096  T T T # O
     0.64451     0.66726     0.81569  T T T # O
     0.33416     0.64745     0.88951  T T T # O
     0.33416     0.31713     0.09747  T T T # O
     0.93262     0.92263     0.99349  T T T # O
     0.43262     0.79195     0.99349  T T T # O
     0.73422     0.73229     0.13386  T T T # O
     0.22073     0.66726     0.81569  T T T # O");
}
// 70e8dd41-45af-4712-b095-802079ac6eb4 ends here

// [[file:~/Workspace/Programming/gchemol/gchemol.note::e71c5ee4-27e3-4c03-b626-e7ae375b4510][e71c5ee4-27e3-4c03-b626-e7ae375b4510]]
use formats::ChemFileLike;
use errors::*;
use lattice::Lattice;
use io;
use std::path::Path;

pub struct POSCARFile();

impl ChemFileLike for POSCARFile {
    fn ftype(&self) -> &str {
        "vasp/poscar"
    }

    fn extensions(&self) -> Vec<&str> {
        ["POSCAR", "CONTCAR", ".poscar"].to_vec()
    }

    // fn parse<P: AsRef<Path>>(&self, filename: P) -> Result<Vec<Molecule>> {
    fn parse(&self, filename: &str) -> Result<Vec<Molecule>> {
        // let path = filename.as_ref();
        let path = filename;

        let txt = io::read_file(path)?;
        // TODO: how to handle parsing error?
        let mol = poscar_molecule(&txt)?;

        Ok(vec![mol])
    }
}

#[test]
fn test_vasp_poscar_parse() {
    let poscar = POSCARFile();
    let mols = poscar.parse("tests/files/vasp/POSCAR").unwrap();
    assert_eq!(1, mols.len());
    assert_eq!(365, mols[0].natoms());
}
// e71c5ee4-27e3-4c03-b626-e7ae375b4510 ends here
