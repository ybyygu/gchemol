// [[file:~/Workspace/Programming/gchemol/gchemol.note::70e8dd41-45af-4712-b095-802079ac6eb4][70e8dd41-45af-4712-b095-802079ac6eb4]]
use super::*;

use nom::ErrorKind;

named!(poscar_lattice_constant<&str, f64>,
    terminated!(
        double_s,
        end_of_line
    )
);

#[test]
fn test_poscar_lattice_constant() {
    let x = poscar_lattice_constant("1.0000\n");
}

named!(poscar_cell_vectors<&str, [[f64; 3]; 3]>,
    dbg!(
        do_parse!(
            va: ws!(xyz_array) >>
            vb: ws!(xyz_array) >>
            vc: ws!(xyz_array) >>
            ([va, vb, vc])
        )
    )
);

#[test]
fn test_poscar_cell_vectors() {
    let (_, x) = poscar_cell_vectors(" 21.23300000  0.00000000  0.00000000
  0.00000000 26.60400000  0.00000000
  0.00000000  0.00000000 12.67600000\n").unwrap();
    assert_eq!(21.233, x[0][0]);
}

named!(poscar_ion_types<&str, (Vec<&str>, Vec<usize>)>,
    return_error!(
        ErrorKind::Custom(1),
        do_parse!(
            syms: many1!(sp!(alpha))          >>
                  end_of_line                 >>
            nums: many1!(sp!(unsigned_digit)) >>
                  end_of_line                 >>
            ((syms, nums))
        )
    )
);

#[test]
fn test_poscar_ion_types() {
    let x = poscar_ion_types(" O    Si   C    N    H
 225  112   8    1    19 \n");
}

// Selective dynamics
// Direct
named!(poscar_select_direct_lines<&str, (&str, &str)>,
    do_parse!(
        line1: sp!(take_until_end_of_line) >>
        line2: sp!(take_until_end_of_line) >>
        ((line1, line2))
    )
);

#[test]
fn test_poscar_select_direct_lines() {
    let x = poscar_select_direct_lines("Selective dynamics
Direct");
}

// 0.05185     0.39121     0.29921  T T T # O
// 0.81339     0.57337     0.68777  T T T # O
named!(poscar_position<&str, ([f64; 3], &str)>,
    do_parse!(
        position: sp!(xyz_array)                            >>
        remained: take_until_end_of_line                    >>
        ((position, remained))
    )
);

#[test]
fn test_poscar_position() {
    let x = poscar_position("     0.05185     0.39121     0.29921  T T T # O \n");
    let x = poscar_position("     0.05185     0.39121     0.29921 \n");
}

#[derive(Debug, Clone)]
struct PoscarData<'a> {
    title: &'a str,
    selective_dynamics: bool,
    direct_coordinates: bool,
    lattice_constant: f64,
    cell_vectors: [[f64;3]; 3],
    ion_types: (Vec<&'a str>, Vec<usize>),
    ion_positions: Vec<([f64; 3], &'a str)>
}

named!(get_molecule_from<&str, Molecule>,
    do_parse!(
        title            : take_until_end_of_line     >>
        lattice_constant : poscar_lattice_constant    >>
        cell_vectors     : poscar_cell_vectors        >>
        ion_types        : poscar_ion_types           >>
        labels           : poscar_select_direct_lines >>
        ion_positions    : many1!(poscar_position)    >>
        (
            {
                let selective_dynamics = labels.0.starts_with("S");
                let direct_coordinates = labels.1.starts_with("D");
                let mut mol = Molecule::new(title.trim());
                let mut tvs = cell_vectors;
                let mut lat = Lattice::new(tvs);
                lat.scale_by(lattice_constant);

                let mut symbols = vec![];
                let (syms, nums) = ion_types;

                for (&sym, &num) in syms.iter().zip(nums.iter()) {
                    for _ in 0..num {
                        symbols.push(sym);
                    }
                }

                if symbols.len() != ion_positions.len() {
                    eprintln!("Inconsistency: some ions data not correctly parsed.");
                }

                for (&sym, (pos, codes)) in symbols.iter().zip(ion_positions) {
                    let mut pos = pos;
                    if direct_coordinates {
                        pos = lat.to_cart(pos);
                    }
                    let a = Atom::new(sym, pos);
                    mol.add_atom(a);
                }
                mol.set_lattice(lat);

                mol
            }
        )
    )
);


#[test]
fn test_poscar_molecule() {
    let x = get_molecule_from("Molecule # generated by gosh
1.0
 21.23300000  0.00000000  0.00000000
  0.00000000 26.60400000  0.00000000
  0.00000000  0.00000000 12.67600000
 O    Si   C    N    H
225  112   8    1    19
Selective dynamics
Direct
     0.05185     0.39121     0.29921  T T T # O
     0.81339     0.57337     0.68777  T T T # O
     0.73422     0.23229     0.85313  T T T # O
     0.02246     0.05156     0.49349  T T T # O
     0.64451     0.66726     0.17130  T T T # O
     0.05185     0.07337     0.29921  T T T # O
     0.60095     0.57471     0.17096  T T T # O
     0.64451     0.66726     0.81569  T T T # O
     0.33416     0.64745     0.88951  T T T # O
     0.33416     0.31713     0.09747  T T T # O
     0.93262     0.92263     0.99349  T T T # O
     0.43262     0.79195     0.99349  T T T # O
     0.73422     0.73229     0.13386  T T T # O
     0.22073     0.66726     0.81569  T T T # O");
}
// 70e8dd41-45af-4712-b095-802079ac6eb4 ends here

// [[file:~/Workspace/Programming/gchemol/gchemol.note::e71c5ee4-27e3-4c03-b626-e7ae375b4510][e71c5ee4-27e3-4c03-b626-e7ae375b4510]]
use io;

pub struct POSCARFile();

impl ChemFileLike for POSCARFile {
    fn ftype(&self) -> &str {
        "vasp/poscar"
    }

    fn extensions(&self) -> Vec<&str> {
        ["POSCAR", "CONTCAR", ".poscar"].to_vec()
    }

    fn parse_molecule<'a>(&self, chunk: &'a str) -> IResult<&'a str, Molecule> {
        get_molecule_from(chunk)
    }
}

#[test]
fn test_vasp_poscar_parse() {
    let poscar = POSCARFile();
    let mols = poscar.parse("tests/files/vasp/POSCAR").unwrap();
    assert_eq!(1, mols.len());
    assert_eq!(365, mols[0].natoms());
}
// e71c5ee4-27e3-4c03-b626-e7ae375b4510 ends here
