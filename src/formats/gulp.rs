// [[file:~/Workspace/Programming/gchemol/formats.note::b42aeb90-44d6-4404-b19c-2c33bc0e18ff][b42aeb90-44d6-4404-b19c-2c33bc0e18ff]]
use indexmap;
use super::*;

const EV2HARTREE: f64 = 1.0 / 27.21138386;

/// representing a GULP .gin input file (write only)
///
/// Notes
/// -----
/// special parameters
/// gin.keywordline = 'opti conv lbfgs noauto'
pub struct GulpInputFile();

fn get_bond_order_label(bo: f64) -> String {
    let sbo = format!("{:.1}", bo);
    let x = match sbo.as_ref() {
        "1.0" => "single",
        "2.0" => "double",
        "3.0" => "treble",
        "4.0" => "quadruple",
        "1.5" => "resonant",
        _ => {
            eprintln!("undefined bond type: {}", sbo);
            sbo.as_ref()
        },
    };

    x.into()
}

impl ChemFileLike for GulpInputFile {
    fn ftype(&self) -> &str {
        "gulp/input"
    }

    fn extensions(&self) -> Vec<&str> {
        vec![".gin", ".gulp"]
    }

    fn parse_molecule<'a>(&self, chunk: &'a str) -> IResult<&'a str, Molecule> {
        unimplemented!()
    }

    fn format(&self, mols: &Vec<Molecule>) -> Result<String> {
        if mols.len() > 1 {
            eprintln!("WARNING: only the last molecule will be used.");
        }

        let mol = &mols.last().ok_or(format_err!("no molecule"))?;
        let mut lines = String::new();
        lines.push_str("# put keywords here\n");
        lines.push_str("opti conv noauto nosymmetry\n\n");
        lines.push_str("title\n");
        // FIXME: multiple lines
        let title = mol.title();
        if title.is_empty() {
            let title = "generated by gchemol";
        }
        lines.push_str(&format!("{}\n", title));
        lines.push_str("end\n");

        // lattice
        if let Some(mut lattice) = mol.lattice {
            lines.push_str("\nvectors\n");
            for [x, y, z] in lattice.vectors().into_iter() {
                lines.push_str(&format!("{:7.3}{:7.3}{:7.3}\n", x, y, z));
            }
        }

        lines.push_str("\n# put coordinates here\n");
        if mol.lattice.is_some() {
            lines.push_str("frac\n");
        } else {
            lines.push_str("cart\n");
        }

        // Notes
        // -----
        // species = {"C":{"C3_", "C2_"},
        //            "O":{"O2_", "O_3_z"},
        //            "H":{"H_"}}
        lines.push_str("#!! Please change atom labels\n");
        for a in mol.atoms() {
            let [x, y, z] = if let Some(mut lat) = mol.lattice {
                lat.to_frac(a.position())
            } else {
                a.position()
            };

            // FIXME: fit force field
            let label = a.symbol();
            let line = format!("{:5} core {:-12.5} {:-12.5} {:-12.5}\n",
                               label,
                               x,
                               y,
                               z,
            );
            lines.push_str(&line);
        }


        lines.push_str("\nSpecies\n");
        lines.push_str("#!! set atom species here\n");

        // force field
        lines.push_str("\n# assign force filed in library\n");
        lines.push_str("library uff\n");
        lines.push_str("\nspacegroup\n");
        lines.push_str("P 1\n");

        // not shell model
        lines.push_str("# connectivity\n");
        for (i, j, b) in mol.view_bonds() {
            let line = format!("connect {}{:5} {:5}\n", i, j, get_bond_order_label(b.order()));
            lines.push_str(&line);
        }

        lines.push_str("# output options\n");
        lines.push_str("output xyz final.xyz\n");
        lines.push_str("output drv final.drv\n");
        lines.push_str("#output fdf final.fdf\n");
        lines.push_str("output cif final.cif\n");
        lines.push_str("dump every 1 restart.gin\n");

        // final blank lines
        lines.push_str("\n");

        Ok(lines)
    }
}

#[test]
#[ignore]
fn test_formats_gin() {
    let mols = io::read("tests/files/mol2/arginyl-ds.mol2").unwrap();
    io::write("/tmp/a.gin", &mols).unwrap();
}
// b42aeb90-44d6-4404-b19c-2c33bc0e18ff ends here
